{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/Claudia/Desktop/MesQueUnGrupDeDones1.0/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { BehaviorSubject, firstValueFrom, Subject } from 'rxjs';\nimport { map } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"../../../core/services/supabase.service\";\nimport * as i2 from \"../../../core/services/notification.service\";\nimport * as i3 from \"../../../core/services/loading.service\";\nexport class SupabaseReservationsService {\n  constructor(supabase, notificationService, loadingService) {\n    this.supabase = supabase;\n    this.notificationService = notificationService;\n    this.loadingService = loadingService;\n    this.classesSubject = new BehaviorSubject([]);\n    this.reservationsSubject = new BehaviorSubject([]);\n    this.realtimeChannels = {};\n    this.isSubscribed = false;\n    this.destroy$ = new Subject();\n    this.MAX_RETRIES = 3;\n    this.RETRY_DELAY = 2000;\n    this.classes$ = this.classesSubject.asObservable();\n    this.reservations$ = this.reservationsSubject.asObservable();\n    this.setupRealtimeSubscriptions();\n  }\n  ngOnDestroy() {\n    this.destroy$.next();\n    this.destroy$.complete();\n    this.cleanup();\n  }\n  setupRealtimeSubscriptions() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      if (_this.isSubscribed) return;\n      try {\n        yield _this.supabase.ensureInitialized();\n        yield Promise.all([_this.setupClassesSubscription(), _this.setupReservationsSubscription()]);\n        _this.isSubscribed = true;\n      } catch (error) {\n        console.error('Error setting up realtime subscriptions:', error);\n        _this.notificationService.error('Error de connexió. Tornant a intentar...');\n        setTimeout(() => _this.setupRealtimeSubscriptions(), _this.RETRY_DELAY);\n      }\n    })();\n  }\n  setupClassesSubscription() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (_this2.realtimeChannels['classes']) {\n        yield _this2.realtimeChannels['classes'].unsubscribe();\n      }\n      const channel = _this2.supabase.client.channel('classes-changes').on('postgres_changes', {\n        event: '*',\n        schema: 'public',\n        table: 'classes'\n      }, /*#__PURE__*/_asyncToGenerator(function* () {\n        try {\n          yield _this2.getAvailableClasses();\n        } catch (error) {\n          console.error('Error refreshing classes:', error);\n          _this2.notificationService.error('Error al actualitzar les classes. Tornant a intentar...');\n        }\n      })).subscribe(status => {\n        if (status === 'SUBSCRIBED') {\n          console.log('Subscribed to classes changes');\n        } else if (status === 'CHANNEL_ERROR') {\n          console.error('Channel error for classes subscription');\n          _this2.retrySubscription('classes');\n        }\n      });\n      _this2.realtimeChannels['classes'] = channel;\n    })();\n  }\n  setupReservationsSubscription() {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      if (_this3.realtimeChannels['reservations']) {\n        yield _this3.realtimeChannels['reservations'].unsubscribe();\n      }\n      const channel = _this3.supabase.client.channel('reservations-changes').on('postgres_changes', {\n        event: '*',\n        schema: 'public',\n        table: 'reservations'\n      }, /*#__PURE__*/_asyncToGenerator(function* () {\n        try {\n          yield _this3.getUserReservations();\n        } catch (error) {\n          console.error('Error refreshing reservations:', error);\n          _this3.notificationService.error('Error al actualitzar les reserves. Tornant a intentar...');\n        }\n      })).subscribe(status => {\n        if (status === 'SUBSCRIBED') {\n          console.log('Subscribed to reservations changes');\n        } else if (status === 'CHANNEL_ERROR') {\n          console.error('Channel error for reservations subscription');\n          _this3.retrySubscription('reservations');\n        }\n      });\n      _this3.realtimeChannels['reservations'] = channel;\n    })();\n  }\n  retrySubscription(channelName, attempts = this.MAX_RETRIES) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      if (attempts <= 0) {\n        console.error(`Failed to reconnect ${channelName} channel after multiple attempts`);\n        _this4.notificationService.error('Error de connexió. Si us plau, refresca la pàgina.');\n        return;\n      }\n      try {\n        if (_this4.realtimeChannels[channelName]) {\n          yield _this4.realtimeChannels[channelName].unsubscribe();\n        }\n        yield new Promise(resolve => setTimeout(resolve, _this4.RETRY_DELAY));\n        if (channelName === 'classes') {\n          yield _this4.setupClassesSubscription();\n        } else if (channelName === 'reservations') {\n          yield _this4.setupReservationsSubscription();\n        }\n      } catch (error) {\n        console.error(`Error during ${channelName} channel retry:`, error);\n        yield _this4.retrySubscription(channelName, attempts - 1);\n      }\n    })();\n  }\n  withRetry(operation) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      let lastError;\n      for (let i = 0; i < _this5.MAX_RETRIES; i++) {\n        try {\n          return yield operation();\n        } catch (error) {\n          lastError = error;\n          console.error(`Operation failed (attempt ${i + 1}/${_this5.MAX_RETRIES}):`, error);\n          if (i < _this5.MAX_RETRIES - 1) {\n            yield new Promise(resolve => setTimeout(resolve, _this5.RETRY_DELAY));\n            continue;\n          }\n        }\n      }\n      throw lastError;\n    })();\n  }\n  getAvailableClasses() {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      yield _this6.supabase.ensureInitialized();\n      return _this6.loadingService.withLoading( /*#__PURE__*/_asyncToGenerator(function* () {\n        try {\n          const {\n            data,\n            error\n          } = yield _this6.withRetry( /*#__PURE__*/_asyncToGenerator(function* () {\n            const today = new Date();\n            today.setHours(0, 0, 0, 0);\n            return yield _this6.supabase.client.from('classes').select(`\n              *,\n              reservations (\n                id,\n                user_id,\n                status\n              ),\n              waiting_list (\n                id,\n                user_id,\n                position\n              )\n            `).gte('datetime', today.toISOString()).order('datetime', {\n              ascending: true\n            });\n          }));\n          if (error) throw error;\n          const processedClasses = data.map(classData => ({\n            ...classData,\n            reservations: classData.reservations?.filter(r => r.status === 'confirmed') || [],\n            waiting_list: classData.waiting_list?.sort((a, b) => a.position - b.position) || []\n          }));\n          _this6.classesSubject.next(processedClasses);\n          return processedClasses;\n        } catch (error) {\n          console.error('Error fetching classes:', error);\n          _this6.notificationService.error('Error al carregar les classes disponibles. Si us plau, torna-ho a provar.');\n          throw error;\n        }\n      }));\n    })();\n  }\n  getUserReservations() {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      yield _this7.supabase.ensureInitialized();\n      return _this7.loadingService.withLoading( /*#__PURE__*/_asyncToGenerator(function* () {\n        try {\n          const session = yield firstValueFrom(_this7.supabase.session$);\n          if (!session?.user) throw new Error('User not authenticated');\n          const {\n            data,\n            error\n          } = yield _this7.withRetry( /*#__PURE__*/_asyncToGenerator(function* () {\n            return _this7.supabase.client.from('reservations').select(`\n              *,\n              class:classes (*)\n            `).eq('user_id', session.user.id).order('created_at', {\n              ascending: false\n            });\n          }));\n          if (error) throw error;\n          _this7.reservationsSubject.next(data);\n          return data;\n        } catch (error) {\n          console.error('Error fetching user reservations:', error);\n          _this7.notificationService.error('Error al carregar les teves reserves. Si us plau, torna-ho a provar.');\n          throw error;\n        }\n      }));\n    })();\n  }\n  createReservation(classId) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      yield _this8.supabase.ensureInitialized();\n      return _this8.loadingService.withLoading( /*#__PURE__*/_asyncToGenerator(function* () {\n        try {\n          const session = yield firstValueFrom(_this8.supabase.session$);\n          if (!session?.user) throw new Error('User not authenticated');\n          const availability = yield _this8.getClassAvailability(classId);\n          if (availability.reserved >= availability.total) {\n            return _this8.addToWaitingList(classId);\n          }\n          const {\n            data,\n            error\n          } = yield _this8.withRetry( /*#__PURE__*/_asyncToGenerator(function* () {\n            return _this8.supabase.client.from('reservations').insert([{\n              user_id: session.user.id,\n              class_id: classId,\n              status: 'confirmed'\n            }]).select(`\n              *,\n              class:classes (*)\n            `).single();\n          }));\n          if (error) throw error;\n          yield _this8.getUserReservations();\n          yield _this8.getAvailableClasses();\n          _this8.notificationService.success('Reserva realitzada amb èxit');\n          return data;\n        } catch (error) {\n          console.error('Error creating reservation:', error);\n          if (error.message === 'Class is full') {\n            return _this8.addToWaitingList(classId);\n          }\n          _this8.notificationService.error('Error al crear la reserva. Si us plau, torna-ho a provar.');\n          throw error;\n        }\n      }));\n    })();\n  }\n  addToWaitingList(classId) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      yield _this9.supabase.ensureInitialized();\n      try {\n        const session = yield firstValueFrom(_this9.supabase.session$);\n        if (!session?.user) throw new Error('User not authenticated');\n        const {\n          data: lastPosition\n        } = yield _this9.withRetry( /*#__PURE__*/_asyncToGenerator(function* () {\n          return _this9.supabase.client.from('waiting_list').select('position').eq('class_id', classId).order('position', {\n            ascending: false\n          }).limit(1).single();\n        }));\n        const nextPosition = (lastPosition?.position ?? 0) + 1;\n        const {\n          data,\n          error\n        } = yield _this9.withRetry( /*#__PURE__*/_asyncToGenerator(function* () {\n          return _this9.supabase.client.from('waiting_list').insert([{\n            user_id: session.user.id,\n            class_id: classId,\n            position: nextPosition\n          }]).select().single();\n        }));\n        if (error) throw error;\n        yield _this9.getAvailableClasses();\n        _this9.notificationService.info('T\\'hem afegit a la llista d\\'espera');\n        return {\n          ...data,\n          status: 'waitlist'\n        };\n      } catch (error) {\n        console.error('Error adding to waiting list:', error);\n        _this9.notificationService.error('Error al afegir-te a la llista d\\'espera. Si us plau, torna-ho a provar.');\n        throw error;\n      }\n    })();\n  }\n  cancelReservation(reservationId) {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      yield _this10.supabase.ensureInitialized();\n      return _this10.loadingService.withLoading( /*#__PURE__*/_asyncToGenerator(function* () {\n        try {\n          const {\n            error\n          } = yield _this10.withRetry( /*#__PURE__*/_asyncToGenerator(function* () {\n            return _this10.supabase.client.from('reservations').delete().eq('id', reservationId);\n          }));\n          if (error) throw error;\n          yield _this10.getUserReservations();\n          yield _this10.getAvailableClasses();\n          _this10.notificationService.success('Reserva cancel·lada amb èxit');\n        } catch (error) {\n          console.error('Error canceling reservation:', error);\n          _this10.notificationService.error('Error al cancel·lar la reserva. Si us plau, torna-ho a provar.');\n          throw error;\n        }\n      }));\n    })();\n  }\n  getClassAvailability(classId) {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      yield _this11.supabase.ensureInitialized();\n      try {\n        const {\n          data: classData,\n          error: classError\n        } = yield _this11.withRetry( /*#__PURE__*/_asyncToGenerator(function* () {\n          return _this11.supabase.client.from('classes').select(`\n            max_participants,\n            reservations (count),\n            waiting_list (count)\n          `).eq('id', classId).single();\n        }));\n        if (classError) throw classError;\n        return {\n          total: classData.max_participants,\n          reserved: classData.reservations[0].count,\n          waiting: classData.waiting_list[0].count\n        };\n      } catch (error) {\n        console.error('Error getting class availability:', error);\n        _this11.notificationService.error('Error al comprovar la disponibilitat. Si us plau, torna-ho a provar.');\n        throw error;\n      }\n    })();\n  }\n  cleanup() {\n    var _this12 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        for (const channel of Object.values(_this12.realtimeChannels)) {\n          yield channel.unsubscribe();\n        }\n        _this12.realtimeChannels = {};\n        _this12.isSubscribed = false;\n      } catch (error) {\n        console.error('Error cleaning up realtime channels:', error);\n      }\n    })();\n  }\n  getUpcomingClasses() {\n    return this.classes$.pipe(map(classes => {\n      const now = new Date();\n      return classes.filter(c => new Date(c.datetime) > now).sort((a, b) => new Date(a.datetime).getTime() - new Date(b.datetime).getTime());\n    }));\n  }\n  getClassesByDate(date) {\n    return this.classes$.pipe(map(classes => {\n      const selectedDate = new Date(date);\n      selectedDate.setHours(0, 0, 0, 0);\n      const nextDate = new Date(selectedDate);\n      nextDate.setDate(nextDate.getDate() + 1);\n      return classes.filter(c => {\n        const classDate = new Date(c.datetime);\n        return classDate >= selectedDate && classDate < nextDate;\n      });\n    }));\n  }\n  static {\n    this.ɵfac = function SupabaseReservationsService_Factory(t) {\n      return new (t || SupabaseReservationsService)(i0.ɵɵinject(i1.SupabaseService), i0.ɵɵinject(i2.NotificationService), i0.ɵɵinject(i3.LoadingService));\n    };\n  }\n  static {\n    this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: SupabaseReservationsService,\n      factory: SupabaseReservationsService.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}","map":{"version":3,"names":["BehaviorSubject","firstValueFrom","Subject","map","SupabaseReservationsService","constructor","supabase","notificationService","loadingService","classesSubject","reservationsSubject","realtimeChannels","isSubscribed","destroy$","MAX_RETRIES","RETRY_DELAY","classes$","asObservable","reservations$","setupRealtimeSubscriptions","ngOnDestroy","next","complete","cleanup","_this","_asyncToGenerator","ensureInitialized","Promise","all","setupClassesSubscription","setupReservationsSubscription","error","console","setTimeout","_this2","unsubscribe","channel","client","on","event","schema","table","getAvailableClasses","subscribe","status","log","retrySubscription","_this3","getUserReservations","channelName","attempts","_this4","resolve","withRetry","operation","_this5","lastError","i","_this6","withLoading","data","today","Date","setHours","from","select","gte","toISOString","order","ascending","processedClasses","classData","reservations","filter","r","waiting_list","sort","a","b","position","_this7","session","session$","user","Error","eq","id","createReservation","classId","_this8","availability","getClassAvailability","reserved","total","addToWaitingList","insert","user_id","class_id","single","success","message","_this9","lastPosition","limit","nextPosition","info","cancelReservation","reservationId","_this10","delete","_this11","classError","max_participants","count","waiting","_this12","Object","values","getUpcomingClasses","pipe","classes","now","c","datetime","getTime","getClassesByDate","date","selectedDate","nextDate","setDate","getDate","classDate","i0","ɵɵinject","i1","SupabaseService","i2","NotificationService","i3","LoadingService","factory","ɵfac","providedIn"],"sources":["C:\\Users\\Claudia\\Desktop\\MesQueUnGrupDeDones1.0\\src\\app\\features\\reservations\\services\\supabase-reservations.service.ts"],"sourcesContent":["import { Injectable, OnDestroy } from '@angular/core';\nimport { SupabaseService } from '../../../core/services/supabase.service';\nimport { BehaviorSubject, firstValueFrom, Subject, Observable } from 'rxjs';\nimport { takeUntil, map } from 'rxjs/operators';\nimport { Class, Reservation, WaitingListEntry } from '../models/reservation.types';\nimport { RealtimeChannel } from '@supabase/supabase-js';\nimport { NotificationService } from '../../../core/services/notification.service';\nimport { LoadingService } from '../../../core/services/loading.service';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class SupabaseReservationsService implements OnDestroy {\n  private classesSubject = new BehaviorSubject<Class[]>([]);\n  private reservationsSubject = new BehaviorSubject<Reservation[]>([]);\n  private realtimeChannels: { [key: string]: RealtimeChannel } = {};\n  private isSubscribed = false;\n  private destroy$ = new Subject<void>();\n  private readonly MAX_RETRIES = 3;\n  private readonly RETRY_DELAY = 2000;\n\n  classes$ = this.classesSubject.asObservable();\n  reservations$ = this.reservationsSubject.asObservable();\n\n  constructor(\n    private supabase: SupabaseService,\n    private notificationService: NotificationService,\n    private loadingService: LoadingService\n  ) {\n    this.setupRealtimeSubscriptions();\n  }\n\n  ngOnDestroy() {\n    this.destroy$.next();\n    this.destroy$.complete();\n    this.cleanup();\n  }\n\n  private async setupRealtimeSubscriptions() {\n    if (this.isSubscribed) return;\n\n    try {\n      await this.supabase.ensureInitialized();\n      await Promise.all([\n        this.setupClassesSubscription(),\n        this.setupReservationsSubscription()\n      ]);\n      this.isSubscribed = true;\n    } catch (error) {\n      console.error('Error setting up realtime subscriptions:', error);\n      this.notificationService.error('Error de connexió. Tornant a intentar...');\n      setTimeout(() => this.setupRealtimeSubscriptions(), this.RETRY_DELAY);\n    }\n  }\n\n  private async setupClassesSubscription() {\n    if (this.realtimeChannels['classes']) {\n      await this.realtimeChannels['classes'].unsubscribe();\n    }\n\n    const channel = this.supabase.client\n      .channel('classes-changes')\n      .on(\n        'postgres_changes',\n        { event: '*', schema: 'public', table: 'classes' },\n        async () => {\n          try {\n            await this.getAvailableClasses();\n          } catch (error) {\n            console.error('Error refreshing classes:', error);\n            this.notificationService.error('Error al actualitzar les classes. Tornant a intentar...');\n          }\n        }\n      )\n      .subscribe((status) => {\n        if (status === 'SUBSCRIBED') {\n          console.log('Subscribed to classes changes');\n        } else if (status === 'CHANNEL_ERROR') {\n          console.error('Channel error for classes subscription');\n          this.retrySubscription('classes');\n        }\n      });\n\n    this.realtimeChannels['classes'] = channel;\n  }\n\n  private async setupReservationsSubscription() {\n    if (this.realtimeChannels['reservations']) {\n      await this.realtimeChannels['reservations'].unsubscribe();\n    }\n\n    const channel = this.supabase.client\n      .channel('reservations-changes')\n      .on(\n        'postgres_changes',\n        { event: '*', schema: 'public', table: 'reservations' },\n        async () => {\n          try {\n            await this.getUserReservations();\n          } catch (error) {\n            console.error('Error refreshing reservations:', error);\n            this.notificationService.error('Error al actualitzar les reserves. Tornant a intentar...');\n          }\n        }\n      )\n      .subscribe((status) => {\n        if (status === 'SUBSCRIBED') {\n          console.log('Subscribed to reservations changes');\n        } else if (status === 'CHANNEL_ERROR') {\n          console.error('Channel error for reservations subscription');\n          this.retrySubscription('reservations');\n        }\n      });\n\n    this.realtimeChannels['reservations'] = channel;\n  }\n\n  private async retrySubscription(channelName: string, attempts = this.MAX_RETRIES) {\n    if (attempts <= 0) {\n      console.error(`Failed to reconnect ${channelName} channel after multiple attempts`);\n      this.notificationService.error('Error de connexió. Si us plau, refresca la pàgina.');\n      return;\n    }\n\n    try {\n      if (this.realtimeChannels[channelName]) {\n        await this.realtimeChannels[channelName].unsubscribe();\n      }\n      \n      await new Promise(resolve => setTimeout(resolve, this.RETRY_DELAY));\n      \n      if (channelName === 'classes') {\n        await this.setupClassesSubscription();\n      } else if (channelName === 'reservations') {\n        await this.setupReservationsSubscription();\n      }\n    } catch (error) {\n      console.error(`Error during ${channelName} channel retry:`, error);\n      await this.retrySubscription(channelName, attempts - 1);\n    }\n  }\n\n  private async withRetry<T>(operation: () => Promise<T>): Promise<T> {\n    let lastError: any;\n    \n    for (let i = 0; i < this.MAX_RETRIES; i++) {\n      try {\n        return await operation();\n      } catch (error) {\n        lastError = error;\n        console.error(`Operation failed (attempt ${i + 1}/${this.MAX_RETRIES}):`, error);\n        \n        if (i < this.MAX_RETRIES - 1) {\n          await new Promise(resolve => setTimeout(resolve, this.RETRY_DELAY));\n          continue;\n        }\n      }\n    }\n    \n    throw lastError;\n  }\n\n  async getAvailableClasses(): Promise<Class[]> {\n    await this.supabase.ensureInitialized();\n    return this.loadingService.withLoading(async () => {\n      try {\n        \n        const { data, error } = await this.withRetry(async () => {\n          const today = new Date();\n          today.setHours(0, 0, 0, 0);\n\n          return await this.supabase.client\n            .from('classes')\n            .select(`\n              *,\n              reservations (\n                id,\n                user_id,\n                status\n              ),\n              waiting_list (\n                id,\n                user_id,\n                position\n              )\n            `)\n            .gte('datetime', today.toISOString())\n            .order('datetime', { ascending: true });\n        });\n\n        if (error) throw error;\n\n        const processedClasses = (data as Class[]).map(classData => ({\n          ...classData,\n          reservations: classData.reservations?.filter(r => r.status === 'confirmed') || [],\n          waiting_list: classData.waiting_list?.sort((a, b) => a.position - b.position) || []\n        }));\n\n        this.classesSubject.next(processedClasses);\n        return processedClasses;\n      } catch (error) {\n        console.error('Error fetching classes:', error);\n        this.notificationService.error('Error al carregar les classes disponibles. Si us plau, torna-ho a provar.');\n        throw error;\n      }\n    });\n  }\n\n  async getUserReservations(): Promise<Reservation[]> {\n    await this.supabase.ensureInitialized();\n    return this.loadingService.withLoading(async () => {\n      try {\n        const session = await firstValueFrom(this.supabase.session$);\n        if (!session?.user) throw new Error('User not authenticated');\n\n        const { data, error } = await this.withRetry(async () => \n          this.supabase.client\n            .from('reservations')\n            .select(`\n              *,\n              class:classes (*)\n            `)\n            .eq('user_id', session.user.id)\n            .order('created_at', { ascending: false })\n        );\n\n        if (error) throw error;\n\n        this.reservationsSubject.next(data);\n        return data;\n      } catch (error) {\n        console.error('Error fetching user reservations:', error);\n        this.notificationService.error('Error al carregar les teves reserves. Si us plau, torna-ho a provar.');\n        throw error;\n      }\n    });\n  }\n\n  async createReservation(classId: string): Promise<Reservation> {\n    await this.supabase.ensureInitialized();\n    return this.loadingService.withLoading(async () => {\n      try {\n        const session = await firstValueFrom(this.supabase.session$);\n        if (!session?.user) throw new Error('User not authenticated');\n\n        const availability = await this.getClassAvailability(classId);\n        \n        if (availability.reserved >= availability.total) {\n          return this.addToWaitingList(classId);\n        }\n\n        const { data, error } = await this.withRetry(async () =>\n          this.supabase.client\n            .from('reservations')\n            .insert([\n              {\n                user_id: session.user.id,\n                class_id: classId,\n                status: 'confirmed'\n              }\n            ])\n            .select(`\n              *,\n              class:classes (*)\n            `)\n            .single()\n        );\n\n        if (error) throw error;\n\n        await this.getUserReservations();\n        await this.getAvailableClasses();\n        this.notificationService.success('Reserva realitzada amb èxit');\n        return data;\n      } catch (error: any) {\n        console.error('Error creating reservation:', error);\n        if (error.message === 'Class is full') {\n          return this.addToWaitingList(classId);\n        }\n        this.notificationService.error('Error al crear la reserva. Si us plau, torna-ho a provar.');\n        throw error;\n      }\n    });\n  }\n\n  private async addToWaitingList(classId: string): Promise<any> {\n    await this.supabase.ensureInitialized();\n    try {\n      const session = await firstValueFrom(this.supabase.session$);\n      if (!session?.user) throw new Error('User not authenticated');\n\n      const { data: lastPosition } = await this.withRetry(async () =>\n        this.supabase.client\n          .from('waiting_list')\n          .select('position')\n          .eq('class_id', classId)\n          .order('position', { ascending: false })\n          .limit(1)\n          .single()\n      );\n\n      const nextPosition = (lastPosition?.position ?? 0) + 1;\n\n      const { data, error } = await this.withRetry(async () =>\n        this.supabase.client\n          .from('waiting_list')\n          .insert([\n            {\n              user_id: session.user.id,\n              class_id: classId,\n              position: nextPosition\n            }\n          ])\n          .select()\n          .single()\n      );\n\n      if (error) throw error;\n\n      await this.getAvailableClasses();\n      this.notificationService.info('T\\'hem afegit a la llista d\\'espera');\n      return { ...data, status: 'waitlist' };\n    } catch (error) {\n      console.error('Error adding to waiting list:', error);\n      this.notificationService.error('Error al afegir-te a la llista d\\'espera. Si us plau, torna-ho a provar.');\n      throw error;\n    }\n  }\n\n  async cancelReservation(reservationId: string): Promise<void> {\n    await this.supabase.ensureInitialized();\n    return this.loadingService.withLoading(async () => {\n      try {\n        \n        const { error } = await this.withRetry(async () =>\n          this.supabase.client\n            .from('reservations')\n            .delete()\n            .eq('id', reservationId)\n        );\n\n        if (error) throw error;\n\n        await this.getUserReservations();\n        await this.getAvailableClasses();\n        this.notificationService.success('Reserva cancel·lada amb èxit');\n      } catch (error) {\n        console.error('Error canceling reservation:', error);\n        this.notificationService.error('Error al cancel·lar la reserva. Si us plau, torna-ho a provar.');\n        throw error;\n      }\n    });\n  }\n\n  async getClassAvailability(classId: string): Promise<{\n    total: number;\n    reserved: number;\n    waiting: number;\n  }> {\n    await this.supabase.ensureInitialized();\n    try {\n      \n      const { data: classData, error: classError } = await this.withRetry(async () =>\n        this.supabase.client\n          .from('classes')\n          .select(`\n            max_participants,\n            reservations (count),\n            waiting_list (count)\n          `)\n          .eq('id', classId)\n          .single()\n      );\n\n      if (classError) throw classError;\n\n      return {\n        total: classData.max_participants,\n        reserved: classData.reservations[0].count,\n        waiting: classData.waiting_list[0].count\n      };\n    } catch (error) {\n      console.error('Error getting class availability:', error);\n      this.notificationService.error('Error al comprovar la disponibilitat. Si us plau, torna-ho a provar.');\n      throw error;\n    }\n  }\n\n  async cleanup() {\n    try {\n      for (const channel of Object.values(this.realtimeChannels)) {\n        await channel.unsubscribe();\n      }\n      this.realtimeChannels = {};\n      this.isSubscribed = false;\n    } catch (error) {\n      console.error('Error cleaning up realtime channels:', error);\n    }\n  }\n\n  getUpcomingClasses(): Observable<Class[]> {\n    return this.classes$.pipe(\n      map(classes => {\n        const now = new Date();\n        return classes\n          .filter(c => new Date(c.datetime) > now)\n          .sort((a, b) => new Date(a.datetime).getTime() - new Date(b.datetime).getTime());\n      })\n    );\n  }\n\n  getClassesByDate(date: Date): Observable<Class[]> {\n    return this.classes$.pipe(\n      map(classes => {\n        const selectedDate = new Date(date);\n        selectedDate.setHours(0, 0, 0, 0);\n        const nextDate = new Date(selectedDate);\n        nextDate.setDate(nextDate.getDate() + 1);\n        \n        return classes.filter(c => {\n          const classDate = new Date(c.datetime);\n          return classDate >= selectedDate && classDate < nextDate;\n        });\n      })\n    );\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}